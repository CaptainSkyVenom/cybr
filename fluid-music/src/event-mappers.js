const R          = require('ramda');
const noteTypes  = require('./note-types');
const converters = require('./converters');
const random     = require('./random');

/**
 * score.tracksToFluidMessage passes Events through a series of eventMapper
 * methods, which mutate events generated by score.parse, eventually converting
 * them to FluidMessages.
 *
 * In general, eventMapper functions have 5 things they can do:
 * 1) Return the unmodified `Event`, passing it to subsequent eventMappers.
 * 2) Return null or a falsy value - the event will be ignored
 * 3) Return a different Event object, which replaces the input Event
 * 4) Return an array of Event objects, each of which will be parsed by
 *    subsequent eventMapper functions.
 * 5) Add fluid messages to `context.messages`
 * @callback eventMapper
 * @param {Event} note
 * @param {ClipEventContext} context
 */

/**
 * Score.parse passes ClipContext objects as the second argument to
 * eventMapper functions. Its fields specify the context of the NoteObject
 * currently being processed, including the track and clip that contain the
 * note.
 * @typedef {Object} ClipEventContext
 * @property {number} bpm the bpm of the clip, this is needed in 
 *    tracksToReaperProject.
 * @property {Clip} clip the Clip that contains the current event
 * @property {Track} track the Track that contains the current event
 * @property {TracksObject} tracks
 * @property {number} clipIndex index of the clip within the track
 * @property {number} [eventIndex] index of the event within the clip.
 *    score.parse updates this automatically before each eventMapper
 *    callback. Note available in (non-end-user) cases where a callback is
 *    passed an array of events, this will not be available.
 * @property {Object} data this is a convenient place for `eventMapper`
 *    callbacks to store data if (for example) the event mapper needs to
 *    preserve information between callbacks. Like the EventContext, it is
 *    replaced for each Clip.
 */

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapVelocityNumbersToDynamic(event, context) {
  if (!event.hasOwnProperty('d')) return event;

  if (typeof event.d === 'number') {
    event.d = {
      v: event.d,
      dbfs: converters.midiVelocityToDbfs(event.d, -10, 10),
      intensity: R.clamp(0, 1, Math.floor(event.d / 127)),
    }
  }

  // As a convenience, add v directly to the event.
  if (typeof event.d.v === 'number') event.v = event.d.v;

  return event;
}

/**
 * Copy the basic, generic properties from the source to the target. This
 * includes the `.d`ynamic (if it exists), `.startTime` and `.duration`.
 * 
 * This is useful when an eventMapper function returns a different event than
 * the one that was passed in, but needs the same .startTime, .duration, and
 * .d as the input note.
 * @param {Event} source
 * @param {Event} target
 * @returns {Event} the target event;
 */
function copyBasicEventProperties(source, target) {
  target.startTime = source.startTime;
  target.duration = source.duration;
  if (source.hasOwnProperty('d')) target.d = source.d;
  return target;
}

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapRandom(event, context) {
  if (event.type !== 'random') return event;
  const newEvent = Object.assign({}, random.choice(event.choices));
  return copyBasicEventProperties(event, newEvent);
}

/**
* @param {Event} event
* @param {ClipEventContext} context
*/
function mapMidiChords(event, context) {
  if (event.type !== 'midiChord') return event;
  return event.notes.map(note => {
    const newEvent = (typeof note === 'number')
      ? converters.numberToMidiNote(note)
      : Object.assign({}, note);
    return copyBasicEventProperties(event, newEvent);
  });
}

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapAutomation(event, context) {
  if (event.type === 'pluginAuto') {
    if (!event.plugin || !event.param)
      throw new Error(`event with type='pluginAuto' missing either a .plugin or a .param ${JSON.stringify(event)}`)
    if (typeof event.plugin.name !== 'string')
      throw new Error(`event with type='pluginAuto' missing plugin.name string: ${JSON.stringify(event)}`);
    if (event.value == null)
      throw new Error(`event with type='pluginAuto' missing .value: ${JSON.stringify(event)}`);
  } else if (event.type === 'trackAuto') {
    if (!event.param || !event.param.name)
      throw new Error(`event with type='trackAuto' missing .param.name: ${JSON.stringify(event)}`)
  } else {
    return event; // only handle 'trackAuto' and 'pluginAuto' types
  }

  let automation = null;
  if (event.type === 'trackAuto') {
    automation = context.track.automation;
  } else {
    // Find or create the plugin
    const nth     = event.plugin.nth || 0;
    const matches = context.track.plugins.filter(plugin => plugin.name === event.plugin.name && plugin.type == event.plugin.type);
    if (nth >= matches.length) {
      const needed = nth - matches.length + 1;
      R.times(() => {
        const plugin = { // Create PluginInstance object
          name: event.plugin.name,
          automation: {},
          type: event.plugin.type,
        };
        matches.push(plugin);
        context.track.plugins.push(plugin);
      }, needed);
    }
    const plugin = matches[nth];
    automation = plugin.automation;
  }

  const paramName = event.param.name;

  if (!automation.hasOwnProperty(paramName))
    automation[paramName] = {points: []};

  // Create AutomationPoint object
  const autoPoint = { startTime: context.clip.startTime + event.startTime };
  // Check the param for a normalization method
  if (typeof event.param.normalize === 'function')
    autoPoint.normalizedValue = event.param.normalize(event.value);
  else
    autoPoint.explicitValue = event.value;

  if (typeof event.curve === 'number')
    autoPoint.curve = event.curve;

  automation[paramName].points.push(autoPoint);
  return null;
}

/**
* @param {Event} event
* @param {ClipEventContext} context
*/
function mapMidiNotes(event, context) {
  if (event.type !== noteTypes.midiNote) return event; // Arrays will still get returned

  if (!context.clip.midiEvents) {
    context.clip.midiEvents = [];
  }
  context.clip.midiEvents.push(event);
  return null;
}

/**
 * Parse a NoteObject with `type=iLayer`. Its job is to select an event from
 * `note.e.iLayers` based on the current dynamic marking, and replace `note.e`
 * with that event.
 *
 * This is a simple example of an event mapper function which only replaces the
 * NoteObject's event.
 *
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapIntensityLayers(event, context) {
  if (event.type !== noteTypes.iLayers) return event;

  // example iLayer note Object
  // NOTE: .v is optional
  // NOTE: file1 example { type: 'file', path: 'media/kick.wav' }
  // {
  //   startTime: 0,
  //   duration: 0.25,
  //   type: 'iLayers',
  //   iLayers: [file1, file2],
  //   d: { dbfs: -2, intensity: 0.7, v: 64 },
  //   v: 64,
  // }
  let length = event.iLayers.length; // number of layers
  let index = length - 1;              // default to last layer

  // Look for an intensity
  if (event.d && typeof(event.d.intensity) === 'number') {
    index = Math.floor(event.d.intensity * length);
  }
  // If no intensity was found, look for a velocity
  else if (event.d && typeof event.d.v === 'number') {
    index = Math.floor(event.d.v / (127 / event.iLayers.length));
  }

  const newEvent = Object.assign({}, event.iLayers[R.clamp(0, length-1, index)]);
  return copyBasicEventProperties(event, newEvent);
}

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapAudioFiles(event, context) {
  if (event.type !== noteTypes.file) return event;
  if (!context.clip.fileEvents) context.clip.fileEvents = [];
  context.clip.fileEvents.push(event);
  return null;
}

module.exports = {
  mapVelocityNumbersToDynamic,
  mapRandom,
  mapAutomation,
  mapMidiChords,
  mapMidiNotes,
  mapIntensityLayers,
  mapAudioFiles,
  default: [
    mapVelocityNumbersToDynamic,
    mapRandom,
    mapMidiChords,
    mapAutomation,
    mapMidiNotes,
    mapIntensityLayers,
    mapAudioFiles,
  ],
};
