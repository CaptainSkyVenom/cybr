const R          = require('ramda');
const noteTypes  = require('./note-types');
const random     = require('./random');

import { mapAutomation }  from './event-mappers-ts';
import { midiVelocityToDbfs, numberToMidiNote } from './converters';

/**
 * score.tracksToFluidMessage passes Events through a series of eventMapper
 * methods, which mutate events generated by score.parse, eventually converting
 * them to FluidMessages.
 *
 * In general, eventMapper functions have 5 things they can do:
 * 1) Return the unmodified `Event`, passing it to subsequent eventMappers.
 * 2) Return null or a falsy value - the event will be ignored
 * 3) Return a different Event object, which replaces the input Event
 * 4) Return an array of Event objects, each of which will be parsed by
 *    subsequent eventMapper functions.
 * 5) Add fluid messages to `context.messages`
 * @callback eventMapper
 * @param {Event} note
 * @param {ClipEventContext} context
 */

/**
 * Score.parse passes ClipContext objects as the second argument to
 * eventMapper functions. Its fields specify the context of the NoteObject
 * currently being processed, including the track and clip that contain the
 * note.
 * @typedef {Object} ClipEventContextJSDOC
 * @property {number} bpm the bpm of the clip, this is needed in 
 *    tracksToReaperProject.
 * @property {Clip} clip the Clip that contains the current event
 * @property {Track} track the Track that contains the current event
 * @property {number} clipIndex index of the clip within the track
 * @property {number} [eventIndex] index of the event within the clip.
 *    score.parse updates this automatically before each eventMapper
 *    callback. Note available in (non-end-user) cases where a callback is
 *    passed an array of events, this will not be available.
 * @property {Object} data this is a convenient place for `eventMapper`
 *    callbacks to store data if (for example) the event mapper needs to
 *    preserve information between callbacks. Like the EventContext, it is
 *    replaced for each Clip.
 */

/**
 * @param {Event} event
 * @param {ClipEventContextJSDOC} context
 */
function mapVelocityNumbersToDynamic(event, context) {
  if (!event.hasOwnProperty('d')) return event;

  if (typeof event.d === 'number') {
    event.d = {
      v: event.d,
      dbfs: midiVelocityToDbfs(event.d, -10, 10),
      intensity: R.clamp(0, 1, Math.floor(event.d / 127)),
    }
  }

  // As a convenience, add v directly to the event.
  if (typeof event.d.v === 'number') event.v = event.d.v;

  return event;
}

/**
 * Copy the basic, generic properties from the source to the target. This
 * includes the `.d` dynamic (if it exists), `.startTime` and `.duration`.
 * 
 * This is useful when an eventMapper function returns a different event than
 * the one that was passed in, but needs the same .startTime, .duration, and
 * .d as the input note.
 * @param {Event} source
 * @param {Event} target
 * @returns {Event} the target event;
 */
function copyBasicEventProperties(source, target) {
  target.startTime = source.startTime;
  target.duration = source.duration;
  if (source.hasOwnProperty('d')) target.d = source.d;
  return target;
}

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapRandom(event, context) {
  if (event.type !== 'random') return event;
  const newEvent = Object.assign({}, random.choice(event.choices));
  return copyBasicEventProperties(event, newEvent);
}

/**
* @param {Event} event
* @param {ClipEventContext} context
*/
function mapMidiChords(event, context) {
  if (event.type !== 'midiChord') return event;
  return event.notes.map(note => {
    const newEvent = (typeof note === 'number')
      ? numberToMidiNote(note)
      : Object.assign({}, note);
    return copyBasicEventProperties(event, newEvent);
  });
}


/**
* @param {Event} event
* @param {ClipEventContext} context
*/
function mapMidiNotes(event, context) {
  if (event.type !== noteTypes.midiNote) return event; // Arrays will still get returned

  if (typeof event.n !== 'number' ||
    typeof event.duration !== 'number' ||
    typeof event.startTime !== 'number')
    throw new Error('invalid midiNote event: ' + JSON.stringify(event))

  if (!context.clip.midiEvents) {
    context.clip.midiEvents = [];
  }
  context.clip.midiEvents.push(event);
  return null;
}

/**
 * Parse a NoteObject with `type=iLayer`. Its job is to select an event from
 * `note.e.iLayers` based on the current dynamic marking, and replace `note.e`
 * with that event.
 *
 * This is a simple example of an event mapper function which only replaces the
 * NoteObject's event.
 *
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapIntensityLayers(event, context) {
  if (event.type !== noteTypes.iLayers) return event;

  // example iLayer note Object
  // NOTE: .v is optional
  // NOTE: file1 example { type: 'file', path: 'media/kick.wav' }
  // {
  //   startTime: 0,
  //   duration: 0.25,
  //   type: 'iLayers',
  //   iLayers: [file1, file2],
  //   d: { dbfs: -2, intensity: 0.7, v: 64 },
  //   v: 64,
  // }
  let length = event.iLayers.length; // number of layers
  let index = length - 1;              // default to last layer

  // Look for an intensity
  if (event.d && typeof(event.d.intensity) === 'number') {
    index = Math.floor(event.d.intensity * length);
  }
  // If no intensity was found, look for a velocity
  else if (event.d && typeof event.d.v === 'number') {
    index = Math.floor(event.d.v / (127 / event.iLayers.length));
  }

  const newEvent = Object.assign({}, event.iLayers[R.clamp(0, length-1, index)]);
  return copyBasicEventProperties(event, newEvent);
}

/**
 * @param {Event} event
 * @param {ClipEventContext} context
 */
function mapAudioFiles(event, context) {
  if (event.type !== noteTypes.file) return event;
  if (!context.clip.fileEvents) context.clip.fileEvents = [];
  context.clip.fileEvents.push(event);
  return null;
}

module.exports = {
  mapVelocityNumbersToDynamic,
  mapRandom,
  mapAutomation,
  mapMidiChords,
  mapMidiNotes,
  mapIntensityLayers,
  mapAudioFiles,
  default: [
    mapVelocityNumbersToDynamic,
    mapRandom,
    mapMidiChords,
    mapAutomation,
    mapMidiNotes,
    mapIntensityLayers,
    mapAudioFiles,
  ],
};
