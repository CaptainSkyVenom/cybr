const R          = require('ramda');
const fluid      = require('./fluid/index');
const noteTypes  = require('./note-types');
const converters = require('./converters');
const { clip } = require('./fluid/index');

/**
 * score.tracksToFluidMessage passes ClipEvents through a series of eventMapper
 * methods, which mutate events generated by score.parse, eventually converting
 * them to FluidMessages.
 *
 * In general, eventMapper functions have 5 things they can do:
 * 1) Return the unmodified `ClipEvent`, passing it to subsequent eventMappers.
 * 2) Return null or a falsy value - the event will be ignored
 * 3) Return a different Event object, which replaces the input Event
 * 4) Return an array of Event objects, each of which will be parsed by
 *    subsequent eventMapper functions.
 * 5) Add fluid messages to `context.messages`
 * @callback eventMapper
 * @param {ClipEvent} note
 * @param {ClipEventContext} context
 */

/**
 * Score.parse passes ClipContext objects as the second argument to
 * eventMapper functions. Its fields specify the context of the NoteObject
 * currently being processed, including the track and clip that contain the
 * note.
 * @typedef {Object} ClipEventContext
 * @property {Clip} clip the Clip that contains the current event
 * @property {Track} track the Track that contains the current event
 * @property {TracksObject} tracks
 * @property {number} clipIndex index of the clip within the track
 * @property {number} [eventIndex] index of the event within the clip.
 *    score.parse updates this automatically before each eventMapper
 *    callback. Note available in (non-end-user) cases where a callback is
 *    passed an array of events, this will not be available.
 * @property {Object} data this is a convenient place for `eventMapper`
 *    callbacks to store data if (for example) the event mapper needs to
 *    preserve information between callbacks. Like the EventContext, it is
 *    replaced for each Clip.
 */

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapVelocityNumbersToDynamic(event, context) {
  if (!event.hasOwnProperty('d')) return event;

  if (typeof event.d === 'number') {
    event.d = {
      v: event.d,
      dbfs: converters.midiVelocityToDbfs(event.d, -10, 10),
      intensity: R.clamp(0, 1, Math.floor(event.d / 127)),
    }
  }

  // As a convenience, add v directly to the event.
  if (typeof event.d.v === 'number') event.v = event.d.v;

  return event;
}

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapNumbersToMidiNotes(event, context) {
  if (typeof event.n !== 'number') return event;
  event.n = {type: noteTypes.midiNote, n: event.n }
  return event;
}

/**
* @param {ClipEvent} event
* @param {ClipEventContext} context
*/
function mapMidiNotes(event, context) {
  if (event.n.type !== noteTypes.midiNote) return event; // Arrays will still get returned

  if (!context.clip.midiEvents) {
    context.clip.midiEvents = [];
  }
  context.clip.midiEvents.push(event);
  return null;
}

/**
 * Parse a NoteObject with `type=iLayer`. Its job is to select an event from
 * `note.e.iLayers` based on the current dynamic marking, and replace `note.e`
 * with that event.
 *
 * This is a simple example of an event mapper function which only replaces the
 * NoteObject's event.
 *
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapIntensityLayers(event, context) {
  if (!event.n || event.n.type !== noteTypes.iLayers) return event;

  // example iLayer note Object
  // NOTE: .v is optional
  // NOTE: file1 example { type: 'file', path: 'media/kick.wav' }
  // {
  //   s: 0, l: 0.25, v: 64,
  //   n: { type: 'iLayers', iLayers: [file1, file2] },
  //   d: { dbfs: -2, intensity: 0.7, v: 64 }
  // }
  let length = event.n.iLayers.length; // number of layers
  let index = length - 1;              // default to last layer

  // Look for an intensity
  if (event.d && typeof(event.d.intensity) === 'number') {
    index = Math.floor(event.d.intensity * length);
  }
  // If no intensity was found, look for a velocity
  else if (typeof event.v === 'number') {
    index = Math.floor(event.v / (127 / event.n.iLayers.length));
  }

  event.n = event.n.iLayers[R.clamp(0, length-1, index)]
  return event;
}

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapAudioFiles(event, context) {
  if (!event.hasOwnProperty('n') || event.n.type !== noteTypes.file) return event;
  if (!context.clip.fileEvents) context.clip.fileEvents = [];
  context.clip.fileEvents.push(event);
  return null;
}

module.exports = {
  mapVelocityNumbersToDynamic,
  mapNumbersToMidiNotes,
  mapMidiNotes,
  mapIntensityLayers,
  mapAudioFiles,
  default: [
    mapVelocityNumbersToDynamic,
    mapNumbersToMidiNotes,
    mapMidiNotes,
    mapIntensityLayers,
    mapAudioFiles,
  ],
};
