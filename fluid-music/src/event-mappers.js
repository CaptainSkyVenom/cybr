const R          = require('ramda');
const fluid      = require('./fluid/index');
const noteTypes  = require('./note-types');
const converters = require('./converters');

/**
 * score.tracksToFluidMessage passes ClipEvents through a series of eventMapper
 * methods, which mutate events generated by score.parse, eventually converting
 * them to FluidMessages.
 *
 * In general, eventMapper functions have 5 things they can do:
 * 1) Return the unmodified `ClipEvent`, passing it to subsequent eventMappers.
 * 2) Return null or a falsy value - the event will be ignored
 * 3) Return a different Event object, which replaces the input Event
 * 4) Return an array of Event objects, each of which will be parsed by
 *    subsequent eventMapper functions.
 * 5) Add fluid messages to `context.messages`
 * @callback eventMapper
 * @param {ClipEvent} note
 * @param {ClipEventContext} context
 */

/**
 * Score.parse passes ClipEventContext objects as the second argument to
 * eventMapper functions. Its fields specify the context of the NoteObject
 * currently being processed, including the track and clip that contain the
 * note.
 * @typedef {Object} ClipEventContext
 * @property {Clip} clip the Clip that contains the current event
 * @property {Track} track the Track that contains the current event
 * @property {TracksObject} tracks
 * @property {FluidMessage[]} messages
 * @property {number} clipIndex index of the clip within the track
 * @property {number} eventIndex index of the event within the clip.
 *    tracksToFluidMessage updates this automatically before each eventMapper
 *    callback.
 * @property {Object} data this is a convenient place for `eventMapper`
 *    callbacks to store data if (for example) the event mapper needs to
 *    preserve information between callbacks. Like the EventContext, it is
 *    replaced for each Clip.
 */

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapVelocityNumbersToDynamic(event, context) {
  if (!event.hasOwnProperty('d')) return event;

  if (typeof event.d === 'number') {
    event.d = {
      v: event.d,
      dbfs: converters.midiVelocityToDbfs(event.d, -10, 10),
      intensity: R.clamp(0, 1, Math.floor(event.d / 127)),
    }
  }

  // As a convenience, add v directly to the event.
  if (typeof event.d.v === 'number') event.v = event.d.v;

  return event;
}

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapNumbersToMidiNotes(event, context) {
  if (typeof event.n !== 'number') return event;
  event.n = {type: noteTypes.midiNote, n: event.n }
  return event;
}

/**
* @param {ClipEvent} event
* @param {ClipEventContext} context
*/
function mapMidiNotes(event, context) {
  if (event.n.type !== noteTypes.midiNote) return event; // Arrays will still get returned

  if (!context.data.createdMidiClip) {
    const clipName  = `${context.track.name} ${context.clipIndex}`
    const startTime = context.clip.startTime;
    const duration  = context.clip.duration;
    const clipMsg   = fluid.midiclip.select(clipName, startTime, duration)
    context.messages.push(clipMsg);
    context.data.createdMidiClip = true;
  }

  // example midi notes
  // NOTE: velocities are optional
  // NOTE: velocity objects can specify .v (midi velocity) and/or dbfs gain
  // { s: 0.0, l: 0.25, n: 60 v: 70 };
  // { s: 0.5, l: 0.25, n: 60 d: { v: 70, dbfs: -12 } };
  const noteMsg = fluid.midiclip.note(event.n.n, event.s, event.l, event.v);
  context.messages.push(noteMsg);
  return null;
}

/**
 * Parse a NoteObject with `type=iLayer`. Its job is to select an event from
 * `note.e.iLayers` based on the current dynamic marking, and replace `note.e`
 * with that event.
 *
 * This is a simple example of an event mapper function which only replaces the
 * NoteObject's event.
 *
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapIntensityLayers(event, context) {
  if (!event.n || event.n.type !== noteTypes.iLayers) return event;

  // example iLayer note Object
  // NOTE: .v is optional
  // NOTE: file1 example { type: 'file', path: 'media/kick.wav' }
  // {
  //   s: 0, l: 0.25, v: 64,
  //   n: { type: 'iLayers', iLayers: [file1, file2] },
  //   d: { dbfs: -2, intensity: 0.7, v: 64 }
  // }
  let length = event.n.iLayers.length; // number of layers
  let index = length - 1;              // default to last layer

  // Look for an intensity
  if (event.d && typeof(event.d.intensity) === 'number') {
    index = Math.floor(event.d.intensity * length);
  }
  // If no intensity was found, look for a velocity
  else if (typeof event.v === 'number') {
    index = Math.floor(event.v / (127 / event.n.iLayers.length));
  }

  event.n = event.n.iLayers[R.clamp(0, length-1, index)]
  return event;
}

/**
 * @param {ClipEvent} event
 * @param {ClipEventContext} context
 */
function mapAudioFiles(event, context) {
  if (!event.hasOwnProperty('n') || event.n.type !== noteTypes.file) return event;

  // exampleClipEvent = {
  //   s: 0.50, // start
  //   l: 0.25, // length
  //   n: { type: 'file', path: 'media/kick.wav' },
  //   d: { v: 70, dbfs: -10 }, // If .v is present here...
  //   v: 70,                   // ...it will also be here...
  //                            // (but vice versa is not guaranteed)
  // };

  const startTime = context.clip.startTime + event.s;

  if (typeof event.n.path !== 'string') {
    console.error(event.n);
    throw new Error('tracksToFluidMessage: A file object found in note library does not have a .path string');
  };

  const clipName = `s${context.clipIndex}.${context.eventIndex}`;
  const msg = [fluid.audiotrack.insertWav(clipName, startTime, event.n.path)];

  // adjust the clip length, unless the event is a .oneShot
  if (!event.n.oneShot) msg.push(fluid.clip.length(event.l));

  // apply fade in/out times (if specified)
  if (typeof event.n.fadeOut === 'number' || typeof event.n.fadeIn === 'number')
    msg.push(fluid.audioclip.fadeInOutSeconds(event.n.fadeIn, event.n.fadeOut));

  // If there is a dynamics object, look for a dbfs property and apply gain.
  if (event.d && typeof(event.d.dbfs) === 'number')
    msg.push(fluid.audioclip.gain(event.d.dbfs));

  context.messages.push(msg);
  return null;
}

module.exports = {
  mapVelocityNumbersToDynamic,
  mapNumbersToMidiNotes,
  mapMidiNotes,
  mapIntensityLayers,
  mapAudioFiles,
  default: [
    mapVelocityNumbersToDynamic,
    mapNumbersToMidiNotes,
    mapMidiNotes,
    mapIntensityLayers,
    mapAudioFiles,
  ],
};
