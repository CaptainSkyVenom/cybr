import { makeVarName, guess } from './cybr/plugin-report-utils'

/**
 * Create a plugin adapter Typescript module from a plugin report
 * @param report A plugin report object generated by cybr. Step size must be odd
 */
export function generatePluginModule(report: any) {
  // remove the "Dry Level" "Wet Level" params that tracktions adds
  const params = report.params.slice(2)
  params.forEach(paramInfo => {
    if (!paramInfo.hasOwnProperty('guess')) paramInfo.guess = guess(paramInfo)
    if (!paramInfo.hasOwnProperty('key')) paramInfo.key = paramInfo.guess.key
    if (!paramInfo.hasOwnProperty('index')) paramInfo.index = paramInfo.tracktionIndex - 2
  })

  const pluginName = report.pluginName
  const pluginType = {
    'VST': 'PluginType.VST2',
    'VST2': 'PluginType.VST2',
    'VST3': 'PluginType.VST3'
  }[report.pluginType]
  const className = makeVarName(pluginName)                 // DragonflyRoom
  const parametersInterfaceName = className + 'Parameters'; // DragonflyRoomParameters

  let output = `import { PluginType, FluidPlugin, PluginAutomationEvent } from './plugin';
const pluginName = '${pluginName}'
const pluginType = '${pluginType}'

export interface ${parametersInterfaceName} {
`
  // For now, assume that every parameter is a number. This may change.
  output += params.map(paramInfo => {
    return `  ${paramInfo.key}? : number;`
  }).join('\n') + '\n}\n'

  output += 'const parameterLibrary = {\n'
  output += params.map(param => {

    let result = `  ${param.key}: { name: '${param.name}', index: ${param.index}, isLinear: ${!!param.guess.isLinear}`
    if (param.guess.range) result += `, range: [${param.guess.range[0]}, ${param.guess.range[1]}] as [number, number]`
    if (param.guess.units) result += `, units: '${param.guess.units}`

    return result + '}'
  }).join(',\n') + '\n}\n'

  return output
}
