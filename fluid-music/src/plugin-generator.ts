import { guess } from './cybr/plugin-report-utils'
import { makeVarName, camelCaseFromParamName, upperFirstLetter } from './plugin-generator-name-helpers'

/**
 * Create a plugin adapter Typescript module from a plugin report
 * @param report A plugin report object generated by cybr. Step size must be odd
 */
export function generatePluginModule(report: any) {
  // remove the "Dry Level" "Wet Level" params that tracktion adds
  const params = report.params.slice(2)
  params.forEach(paramInfo => {
    if (!paramInfo.hasOwnProperty('guess')) paramInfo.guess = guess(paramInfo)
    if (!paramInfo.hasOwnProperty('index')) paramInfo.index = paramInfo.tracktionIndex - 2

    // Assume guesses are correct iff the underlying object does not specify
    for (const k of Object.keys(paramInfo.guess)) {
      if (!paramInfo.hasOwnProperty(k)) paramInfo[k] = paramInfo.guess[k]
    }

    // If we have a normalizer we can make a better key by adding units
    if (!paramInfo.hasOwnProperty('key')) {
      paramInfo.key = camelCaseFromParamName(paramInfo.name)
      if (paramInfo.units && (paramInfo.isLinear || typeof paramInfo.powerFuncB === 'number')) {
        paramInfo.key += upperFirstLetter(paramInfo.units)
      }
    }
  })

  const pluginName = report.pluginName
  const pluginType = {
    'VST': 'PluginType.VST2',
    'VST2': 'PluginType.VST2',
    'VST3': 'PluginType.VST3'
  }[report.pluginType]
  const className = makeVarName(pluginName)                 // DragonflyRoom
  const parametersInterfaceName = className + 'Parameters'; // DragonflyRoomParameters

  let output = `import { PluginType, FluidPlugin, PluginAutomationEvent } from '../plugin';
const pluginName = '${pluginName}'
const pluginType = ${pluginType}

export interface ${parametersInterfaceName} {
`
  // For now, assume that every parameter is a number. This may change.
  output += params.map(paramInfo => {
    return `  ${paramInfo.key}? : number;`
  }).join('\n') + '\n}\n'

  // Create the parameterLibrary
  output += 'const parameterLibrary = {\n'
  output += params.map(param => {
    let result = `  ${param.key}: { name: '${param.name}', index: ${param.index}, isLinear: ${!!param.isLinear}`
    if (param.range) result += `, range: [${param.range[0]}, ${param.range[1]}] as [number, number]`
    if (param.units) result += `, units: '${param.units}'`
    if (typeof param.powerFuncB === 'number') result += `, powerFuncB: ${param.powerFuncB}`
    if (param.choices) result += `, choices: ${JSON.stringify(param.choices)}`
    return result + ' }'
  }).join(',\n') + '\n}\n'

  // makeAutomation includes the helpers for creating automation points
  output += 'const makeAutomation = {\n'
  output += params.map(paramInfo => {
    return `  ${paramInfo.key} (value? : number) : PluginAutomationEvent {
    const event : PluginAutomationEvent = {
      type: 'pluginAuto',
      pluginSelector: { pluginName, pluginType },
      paramKey: '${paramInfo.key}',
      startTime: 0,
      duration: 0,
      curve: 0,
    };
    if (typeof value === 'number') event.value = value;
    return event;
  }`
  }).join(',\n') + '\n}\n'

  // Finally create the class itself
  output += `export class ${className} extends FluidPlugin {
  constructor(
    public readonly parameters : ${parametersInterfaceName} = {},
  ) { super(pluginName, pluginType) }

  readonly parameterLibrary = parameterLibrary;
  readonly makeAutomation = makeAutomation;

  // Static members
  static readonly parameterLibrary = parameterLibrary;
  static readonly makeAutomation = makeAutomation;
}\n`

  return output
}
