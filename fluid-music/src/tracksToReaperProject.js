const rppp = require('rppp')
const tab = require('./tab')

// Requires a bpm


/**
 * Create a `ReaperProject` from a `TracksObject`
 *
 * ```javascript
 * const session = fluid.score.parse(myScore, myConfig);
 * const project = fluid.score.tracksToReaperProject(session.tracks, bpm);
 * ```
 *
 * @param {TracksObject} tracksObject A tracks object generated by score.parse
 * @returns {ReaperProject}
 */
function tracksToReaperProject(tracksObject, bpm) {
  if (!bpm) throw new TypeError('tracksToReaperProject requires a bpm parameter')

  let i = 0;
  const reaperProject = new rppp.objects.ReaperProject();
  reaperProject.getOrCreateStructByToken('TEMPO').params = [bpm, 4, 4];

  // // example tracks object
  // const tracks = {
  //   bass: { clips: [ clip1, clip2... ] },
  //   kick: { clips: [ clip1, clip2... ] },
  // };
  for (const [trackName, track] of Object.entries(tracksObject)) {
    if (tab.reservedKeys.hasOwnProperty(trackName)) {
      continue;
    }

    if (!track.clips || !track.clips.length) {
      if (!tracksObject.plugins.length) {
        console.log(`tracksToFluidMessage: skipping ${trackName}, because it has no .clips and no .plugins`);
        continue;
      }
    }

    // Create a sub-message for each track
    let newTrack = new rppp.objects.ReaperTrack();
    newTrack.getOrCreateStructByToken('NAME').params[0] = trackName;

    track.clips.forEach((clip, clipIndex) => {

      // Create one EventContext object for each clip.
      const context = {
        bpm,
        track,
        clip,
        clipIndex,
        trackObj: newTrack,
        tracks: tracksObject,
        trackName,
        data: {},
      };

      if (clip.midiEvents && clip.midiEvents.length) {
        newTrack.contents.push(midiEventsToReaperObject(clip.midiEvents, context));
      }

      if (clip.fileEvents && clip.fileEvents.length) {
        newTrack.contents = newTrack.contents.concat(fileEventsToReaperObject(clip.fileEvents, context));
      }
      
      reaperProject.addTrack(newTrack);
    }); // track.clips.forEach

    // Handle track specific automation.
    for (const [name, automation] of Object.entries(track.automation)) {
      if (name === 'volume' || name === 'pan') {
        var autoObject;
        if (name === 'volume') autoObject = new rppp.objects.ReaperVolumeAutomation();
        else autoObject = new rppp.objects.ReaperPanAutomation();

        for (const autoPoint of automation.points) {
          let val = 0;
          let curve = 0;

          if (typeof autoPoint.explicitValue === 'number') 
            val = autoPoint.explicitValue;
          else if (typeof autoPoint.normalizedValue === 'number') 
            val = autoPoint.normalizedValue;
          else 
            throw new Error(`AutomationPoint has neither of .explicitValue/.normalizedValue: ${JSON.stringify(autoPoint)}`);

          if (typeof autoPoint.curve === 'number'){
            if (autoPoint.curve < 0) curve = 3;
            else if (autoPoint.curve > 0) curve = 4;
          }

          autoObject.addPoint(autoPoint.startTime * 4 * 60 / bpm, val, curve);
        }
        newTrack.add(autoObject);
      } 
      else {
        throw new Error(`Fluid Track Automation found unsupported parameter: "${name}"`);
      }
    } // for [name, automation] of track.automation
  }

  return reaperProject;
};

/**
 * @param {ClipEvent[]} midiEvents
 * @param {ClipEventContext} context This will not have a .eventIndex
 */
function midiEventsToReaperObject(midiEvents, context) {
  if (typeof context.clip.startTime !== 'number')
    throw new Error('Clip is missing startTime');

  const midiItem = new rppp.objects.ReaperMidiItem();
  const clipName  = `${context.track.name} ${context.clipIndex}`;
  const startTime = context.clip.startTime;
  const duration  = context.clip.duration;
  midiItem.getOrCreateStructByToken('NAME').params[0] = clipName;
  midiItem.getOrCreateStructByToken('POSITION').params[0] = startTime * 4 * 60 / context.bpm;
  midiItem.getOrCreateStructByToken('LENGTH').params[0] = duration * 4 * 60 / context.bpm;

  let midiArray = []
  for (const event of midiEvents) {
    if (event.type === 'midiNote') {
      let velocity = (event.d && typeof event.d.v === 'number')
        ? event.d.v
        : (typeof event.v === 'number')
          ? event.v
          : undefined;
      midiArray.push({n: event.n, s: event.startTime, l: event.duration, v: velocity});
    }
  }

  midiItem.getOrCreateStructByToken('SOURCE').contents = rppp.objects.ReaperMidiItem.getMidiMessage(midiArray);
  return midiItem;
};

/**
 * @param {ClipEvent[]} fileEvents
 * @param {ClipEventContext} context This will not have a .eventIndex
 */
function fileEventsToReaperObject(fileEvents, context) {
  if (typeof context.clip.startTime !== 'number')
    throw new Error('Clip is missing startTime');

  // exampleClipEvent = {
  //   type: 'file',
  //   path: 'media/kick.wav',
  //   startTime: 0.50,
  //   duration: 0.25,
  //   d: { v: 70, dbfs: -10 }, // If .v is present here...
  // };

  return fileEvents.map((event, eventIndex) => {
    const startTime = context.clip.startTime + event.startTime;

    if (typeof event.path !== 'string') {
      console.error(event);
      throw new Error('tracksToFluidMessage: A file event found in the note library does not have a .path string');
    };

    const audioItem = new rppp.objects.ReaperAudioItem();
    const clipName = `s${context.clipIndex}.${eventIndex}`;
    audioItem.getOrCreateStructByToken('NAME').params[0] = clipName;
    audioItem.getOrCreateStructByToken('POSITION').params[0] = startTime * 4 * 60 / context.bpm;;
    audioItem.getOrCreateStructByToken('SOURCE').contents = [{token: 'FILE', params: [event.path]}];

    if (event.startInSourceSeconds)
      audioItem.getOrCreateStructByToken('SOFFS').params[0] = event.startInSourceSeconds

    if (event.oneShot && event.info)
      audioItem.getOrCreateStructByToken('LENGTH').params[0] = event.info.duration - (event.startInSourceSeconds || 0);
    else
      audioItem.getOrCreateStructByToken('LENGTH').params[0] = event.duration * 4 * 60 / context.bpm;

    // apply fade in/out times (if specified)
    if (typeof event.fadeOutSeconds === 'number')
      audioItem.getOrCreateStructByToken('FADEOUT').params = [1, event.fadeOutSeconds, 0, 1, 0, 0]
    if (typeof event.fadeInSeconds === 'number')
      audioItem.getOrCreateStructByToken('FADEIN').params = [1, event.fadeInSeconds, 0, 1, 0, 0]

    // If there is a dynamics object, look for a dbfs property and apply gain.
    if (event.d && typeof(event.d.dbfs) === 'number')
      audioItem.getOrCreateStructByToken('VOLPAN').params = [1, 0, Math.pow(1.1227, event.d.dbfs), -1]

    return audioItem;
  });
}

module.exports = tracksToReaperProject;