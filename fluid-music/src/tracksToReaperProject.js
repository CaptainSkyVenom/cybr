const rppp = require('rppp')

// Requires a bpm


/**
 * Create a `ReaperProject` from a `TracksObject`
 *
 * ```javascript
 * const session = fluid.score.parse(myScore, myConfig);
 * const message = fluid.score.tracksToFluidMessage(session.tracks);
 * ```
 *
 * @param {TracksObject} tracksObject A tracks object generated by score.parse
 * @returns {ReaperProject}
 */
function tracksToFluidMessage(tracksObject) {

  let bpm = 120;
  if(tracksObject.bpm) bpm = tracksObject.bpm;

  let i = 0;
  const reaperProject = rppp.objects.ReaperProject();

  // // example tracks object
  // const tracks = {
  //   bass: { clips: [ clip1, clip2... ] },
  //   kick: { clips: [ clip1, clip2... ] },
  // };
  for (const [trackName, track] of Object.entries(tracksObject)) {
    if (tab.reservedKeys.hasOwnProperty(trackName)) {
      continue;
    }

    if (!track.clips || !track.clips.length) {
      if (!tracksObject.plugins.length) {
        console.log(`tracksToFluidMessage: skipping ${trackName}, because it has no .clips and no .plugins`);
        continue;
      }
    }

    // Create a sub-message for each track
    let newTrack = new rppp.objects.ReaperTrack();
    newTrack.getByToken('NAME').params[0] = trackName;

    track.clips.forEach((clip, clipIndex) => {

      // Create one EventContext object for each clip.
      const context = {
        track,
        clip,
        clipIndex,
        trackObj: newTrack,
        tracks: tracksObject,
        data: {},
      };

      if (clip.midiEvents && clip.midiEvents.length) {
        newTrack.contents.concat(midiEventsToReaperObject(clip.midiEvents, context));
      }

      if (clip.fileEvents && clip.fileEvents.length) {
        newTrack.contents.concat(fileEventsToReaperObject(clip.fileEvents, context));
      }
      
      reaperProject.addTrack(newTrack);
    }); // track.clips.forEach
  }
  
  return reaperProject;
};

/**
 * @param {ClipEvent[]} midiEvents
 * @param {ClipEventContext} context This will not have a .eventIndex
 */
function midiEventsToReaperObject(midiEvents, context) {
  if (typeof context.clip.startTime !== 'number')
    throw new Error('Clip is missing startTime');

  const midiItem = new rppp.objects.ReaperMidiItem();
  const clipName  = `${context.track.name} ${context.clipIndex}`;
  const startTime = context.clip.startTime;
  const duration  = context.clip.duration;
  midiItem.getOrCreateStructByToken('NAME').params[0] = clipName;
  midiItem.getOrCreateStructByToken('POSITION').params[0] = startTime * 4 * bpm / 60;
  midiItem.getOrCreateStructByToken('LENGTH').params[0] = duration * 4 * bpm / 60;

  let midiArray = []
  for (const event of midiEvents) {
    if (event.type === 'midiNote') {
      let velocity = (event.d && typeof event.d.v === 'number')
        ? event.d.v
        : (typeof event.v === 'number')
          ? event.v
          : undefined;
      midiArray.push({n: event.n, s: event.startTime, l: event.length, v: velocity});
    }
  }

  midiItem.getOrCreateStructByToken('SOURCE').contents = rppp.objects.ReaperMidiItem.getMidiMessage(midiArray);
  return midiItem;
};

/**
 * @param {ClipEvent[]} fileEvents
 * @param {ClipEventContext} context This will not have a .eventIndex
 */
function fileEventsToReaperObject(fileEvents, context) {
  if (typeof context.clip.startTime !== 'number')
    throw new Error('Clip is missing startTime');

  // exampleClipEvent = {
  //   type: 'file',
  //   path: 'media/kick.wav',
  //   startTime: 0.50,
  //   length: 0.25,
  //   d: { v: 70, dbfs: -10 }, // If .v is present here...
  // };

  return fileEvents.map((event, eventIndex) => {
    const startTime = context.clip.startTime + event.startTime;

    if (typeof event.path !== 'string') {
      console.error(event);
      throw new Error('tracksToFluidMessage: A file event found in the note library does not have a .path string');
    };

    const audioItem = rppp.objects.ReaperAudioItem();
    const clipName = `s${context.clipIndex}.${eventIndex}`;
    audioItem.getOrCreateStructByToken('NAME').params[0] = clipName;
    audioItem.getOrCreateStructByToken('POSITION').params[0] = startTime * 4 * bpm / 60;;
    audioItem.getOrCreateStructByToken('SOURCE').contents = [{token: 'FILE', params: [event.path]}];

    if (event.startInSourceSeconds)
      audioItem.getOrCreateStructByToken('SOFFS').params[0] = event.startInSourceSeconds

    // adjust the clip length, unless the event is a .oneShot
    if (!event.oneShot)
      audioItem.getOrCreateStructByToken('LENGTH').params[0] = event.length * 4 * bpm / 60;

    // apply fade in/out times (if specified)
    if (typeof event.fadeOutSeconds === 'number')
      audioItem.getOrCreateStructByToken('FADEOUT').params = [1, event.fadeOutSeconds, 0, 1, 0, 0]
    if (typeof event.fadeInSeconds === 'number')
      audioItem.getOrCreateStructByToken('FADEIN').params = [1, event.fadeInSeconds, 0, 1, 0, 0]

    // If there is a dynamics object, look for a dbfs property and apply gain.
    if (event.d && typeof(event.d.dbfs) === 'number')
      audioItem.getOrCreateStructByToken('VOLPAN').params = [1, 0, Math.pow(1.1227, event.d.dbfs), -1]

    return audioItem;
  });
}
